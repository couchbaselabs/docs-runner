name: Doc Style Checker

on:
  workflow_call:
    inputs:
      repository:
        description: "The repository to check out"
        required: true
        type: string
      path:
        type: string
        description: "The startPath pointing to the folder containing documentation"
        required: false
        default: "."
      pull_request_number:
        type: string
        description: "The pull request number to check out"
        required: true
      base_sha:
        type: string
        description: "The base sha to diff against"
        required: true
      head_sha:
        type: string
        description: "The head sha to comment against"
        required: true
    secrets:
      GEMINI_API_KEY:
        description: "Google Gemini API key"
        required: true
      GEMINI_API_KEY_2:
        description: "Google Gemini API key"
        required: true
      GEMINI_API_KEY_3:
        description: "Google Gemini API key"
        required: true
      ACTION_TOKEN:
        description: "GitHub token for posting comments"
        required: true
  workflow_dispatch:  # Add this for manual testing
    inputs:
      test_mode:
        description: "Run in test mode"
        default: true
        type: boolean

jobs:
  doc-style-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repository }}
          ref: ${{ inputs.head_sha }}
          fetch-depth: 100
          path: content-repo

      - name: Get changed documentation files
        id: changed-files
        working-directory: ./content-repo
        run: |
          echo "Getting changed files between ${{ inputs.base_sha }} and ${{ inputs.head_sha }}"
          CHANGED_FILES=$(git diff --name-only ${{ inputs.base_sha }} ${{ inputs.head_sha }} | grep -E '\.(adoc|md)$' || true)
          echo "Changed documentation files:"
          echo "$CHANGED_FILES"
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Process changed documentation files
        if: steps.changed-files.outputs.files != ''
        working-directory: ./content-repo
        run: |
          mkdir -p /tmp/doc-processing
          echo "Processing files..."
          
          echo '${{ steps.changed-files.outputs.files }}' | while IFS= read -r file; do
            if [[ -n "$file" && -f "$file" ]]; then
              echo "Preparing: $file"
              SAFE_NAME=$(echo "$(basename "$file")" | sed 's/[^a-zA-Z0-9._-]/_/g')
              
              # Read file content and create JSON properly
              cat > "/tmp/doc-processing/${SAFE_NAME}.meta" << 'METAEOF'
          {
            "filename": "FILE_PLACEHOLDER",
            "content": "CONTENT_PLACEHOLDER"
          }
          METAEOF
              
              # Replace placeholders with actual values using proper escaping
              sed -i "s|FILE_PLACEHOLDER|$file|g" "/tmp/doc-processing/${SAFE_NAME}.meta"
              
              # Use Python to properly escape JSON content
              python3 -c "
              import json
              import sys
              
              with open('$file', 'r', encoding='utf-8') as f:
                  content = f.read()
              
              # Read the template
              with open('/tmp/doc-processing/${SAFE_NAME}.meta', 'r') as f:
                  template = f.read()
              
              # Replace content placeholder with properly escaped JSON
              escaped_content = json.dumps(content)
              final_json = template.replace('\"CONTENT_PLACEHOLDER\"', escaped_content)
              
              with open('/tmp/doc-processing/${SAFE_NAME}.meta', 'w') as f:
                  f.write(final_json)
              "
              echo "‚úì Prepared $file"
            fi
          done

      - name: Setup Node.js
        if: steps.changed-files.outputs.files != ''
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Run Doc Style Checker
        if: steps.changed-files.outputs.files != ''
        run: |
          cat > check_docs.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const https = require('https');
          
          async function checkDocStyle(content, filename) {
            const data = JSON.stringify({
              content: content,
              filename: filename
            });
            
            const options = {
              hostname: 'doc-style-checker.vercel.app',
              path: '/api/check-style',
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Content-Length': data.length,
                'User-Agent': 'GitHub-Actions-Doc-Checker/1.0'
              }
            };
            
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let responseData = '';
                res.on('data', (chunk) => {
                  responseData += chunk;
                });
                res.on('end', () => {
                  try {
                    console.log(`Response status: ${res.statusCode}`);
                    console.log(`Response body: ${responseData}`);
                    
                    if (res.statusCode !== 200) {
                      throw new Error(`HTTP ${res.statusCode}: ${responseData}`);
                    }
                    const result = JSON.parse(responseData);
                    resolve(result);
                  } catch (e) {
                    console.error('Response parsing error:', e.message);
                    console.error('Raw response:', responseData);
                    reject(e);
                  }
                });
              });
              
              req.on('error', (e) => {
                reject(e);
              });
              
              req.setTimeout(30000, () => {
                req.destroy();
                reject(new Error('Request timeout'));
              });
              
              req.write(data);
              req.end();
            });
          }
          
          async function processAllFiles() {
            const processingDir = '/tmp/doc-processing';
            const results = {};
            
            if (!fs.existsSync(processingDir)) {
              console.log('No processing directory found');
              return results;
            }
            
            const metaFiles = fs.readdirSync(processingDir).filter(f => f.endsWith('.meta'));
            console.log(`Found ${metaFiles.length} file(s) to process`);
            
            for (const metaFile of metaFiles) {
              const metaPath = path.join(processingDir, metaFile);
              
              try {
                const metadata = JSON.parse(fs.readFileSync(metaPath, 'utf8'));
                console.log(`üîç Checking: ${metadata.filename}`);
                
                const result = await checkDocStyle(metadata.content, metadata.filename);
                results[metadata.filename] = result;
                
                const issueCount = result.issues ? result.issues.length : 0;
                console.log(`‚úì ${metadata.filename}: ${issueCount} issue(s) found`);
                
                await new Promise(resolve => setTimeout(resolve, 2000));
                
              } catch (error) {
                console.error(`‚úó Error processing ${metaFile}:`, error.message);
                const filename = metaFile.replace('.meta', '');
                results[filename] = { error: error.message };
              }
            }
            
            return results;
          }
          
          processAllFiles()
            .then(results => {
              fs.writeFileSync('/tmp/style-check-results.json', JSON.stringify(results, null, 2));
              console.log('üìä Style check completed');
            })
            .catch(error => {
              console.error('‚ùå Style check failed:', error);
              process.exit(1);
            });
          EOF
          
          node check_docs.js

      - name: Post PR Comment
        if: steps.changed-files.outputs.files != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTION_TOKEN }}
          script: |
            const fs = require('fs');
            
            let results = {};
            try {
              const resultsData = fs.readFileSync('/tmp/style-check-results.json', 'utf8');
              results = JSON.parse(resultsData);
            } catch (error) {
              console.log('No results to process');
              return;
            }
            
            console.log(`Processing results for ${Object.keys(results).length} files`);
            
            let comment = '## üìù Doc Style Checker Results\n\n';
            let hasIssues = false;
            let totalIssues = 0;
            
            for (const [filename, result] of Object.entries(results)) {
              if (result.error) {
                comment += `### ‚ùå ${filename}\n**Error:** \`${result.error}\`\n\n`;
                continue;
              }
              
              if (!result.issues || result.issues.length === 0) {
                comment += `### ‚úÖ ${filename}\nNo style issues found!\n\n`;
                continue;
              }
              
              // Process the nested structure from your API
              let fileIssues = [];
              result.issues.forEach(categoryGroup => {
                if (categoryGroup.issues && Array.isArray(categoryGroup.issues)) {
                  categoryGroup.issues.forEach(issue => {
                    fileIssues.push({
                      category: categoryGroup.category,
                      ...issue
                    });
                  });
                }
              });
              
              if (fileIssues.length === 0) {
                comment += `### ‚úÖ ${filename}\nNo style issues found!\n\n`;
                continue;
              }
              
              hasIssues = true;
              totalIssues += fileIssues.length;
              comment += `### üìã ${filename}\n**${fileIssues.length} issue${fileIssues.length > 1 ? 's' : ''} found**\n\n`;
              
              // Group by category
              const byCategory = {};
              fileIssues.forEach(issue => {
                const cat = issue.category || 'General';
                if (!byCategory[cat]) byCategory[cat] = [];
                byCategory[cat].push(issue);
              });
              
              for (const [category, issues] of Object.entries(byCategory)) {
                comment += `#### ${category}\n\n`;
                
                issues.forEach((issue, i) => {
                  comment += `<details>\n<summary><strong>Issue ${i + 1}</strong></summary>\n\n`;
                  
                  if (issue.problem) {
                    comment += `**Problem:** ${issue.problem}\n\n`;
                  }
                  
                  if (issue.problematicText) {
                    comment += `**Text:**\n\`\`\`\n${issue.problematicText}\n\`\`\`\n\n`;
                  }
                  
                  if (issue.location) {
                    comment += `**Location:** ${issue.location}\n\n`;
                  }
                  
                  if (issue.suggestion) {
                    comment += `**Suggestion:** ${issue.suggestion}\n\n`;
                  }
                  
                  if (issue.guideline) {
                    comment += `**Guideline:** ${issue.guideline}\n\n`;
                  }
                  
                  comment += `</details>\n\n`;
                });
              }
            }
            
            if (hasIssues) {
              const summary = `üîç **Summary:** ${totalIssues} issue${totalIssues > 1 ? 's' : ''} found across ${Object.keys(results).length} file${Object.keys(results).length > 1 ? 's' : ''}\n\n`;
              comment = comment.replace('## üìù Doc Style Checker Results\n\n', `## üìù Doc Style Checker Results\n\n${summary}`);
            } else if (Object.keys(results).length > 0) {
              comment += 'üéâ **All documentation looks great!** No style issues found.\n\n';
            }
            
            comment += '---\n*Automated by [Doc Style Checker](https://doc-style-checker.vercel.app/) ‚Ä¢ Couchbase Documentation Style Guide*';
            
            try {
              const [owner, repo] = '${{ inputs.repository }}'.split('/');
              await github.rest.issues.createComment({
                issue_number: parseInt('${{ inputs.pull_request_number }}'),
                owner: owner,
                repo: repo,
                body: comment
              });
              console.log('‚úÖ Comment posted successfully');
            } catch (error) {
              console.error('‚ùå Failed to post comment:', error);
              throw error;
            }