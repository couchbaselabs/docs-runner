name: Doc Style Checker

on:
  workflow_call:
    inputs:
      repository:
        description: "The repository to check out"
        required: true
        type: string
      path:
        type: string
        description: "The startPath pointing to the folder containing documentation"
        required: false
        default: "."
      pull_request_number:
        type: string
        description: "The pull request number to check out"
        required: true
      base_sha:
        type: string
        description: "The base sha to diff against"
        required: true
      head_sha:
        type: string
        description: "The head sha to comment against"
        required: true
    secrets:
      GEMINI_API_KEY:
        description: "Google Gemini API key"
        required: true
      GEMINI_API_KEY_2:
        description: "Google Gemini API key"
        required: true
      GEMINI_API_KEY_3:
        description: "Google Gemini API key"
        required: true
      ACTION_TOKEN:
        description: "GitHub token for posting comments"
        required: true
  workflow_dispatch:  # Add this for manual testing
    inputs:
      test_mode:
        description: "Run in test mode"
        default: true
        type: boolean

jobs:
  doc-style-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repository }}
          ref: ${{ inputs.head_sha }}
          fetch-depth: 100
          path: content-repo

      - name: Get changed documentation files
        id: changed-files
        working-directory: ./content-repo
        run: |
          echo "Getting changed files between ${{ inputs.base_sha }} and ${{ inputs.head_sha }}"
          CHANGED_FILES=$(git diff --name-only ${{ inputs.base_sha }} ${{ inputs.head_sha }} | grep -E '\.(adoc|md)$' || true)
          echo "Changed documentation files:"
          echo "$CHANGED_FILES"
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Process changed documentation files
        if: steps.changed-files.outputs.files != ''
        working-directory: ./content-repo
        run: |
          mkdir -p /tmp/doc-processing
          echo "Processing files..."
          
          echo '${{ steps.changed-files.outputs.files }}' | while IFS= read -r file; do
            if [[ -n "$file" && -f "$file" ]]; then
              echo "Preparing: $file"
              SAFE_NAME=$(echo "$(basename "$file")" | sed 's/[^a-zA-Z0-9._-]/_/g')
              
              # Use Node.js directly to create JSON properly
              node -e "
                const fs = require('fs');
                const filename = '$file';
                const outputPath = '/tmp/doc-processing/${SAFE_NAME}.meta';
                
                try {
                  console.log('Reading file:', filename);
                  const content = fs.readFileSync(filename, 'utf8');
                  console.log('File read successfully, length:', content.length);
                  
                  const data = {
                    filename: filename,
                    content: content
                  };
                  
                  console.log('Creating JSON...');
                  const jsonString = JSON.stringify(data, null, 2);
                  console.log('JSON created, writing to:', outputPath);
                  
                  fs.writeFileSync(outputPath, jsonString);
                  console.log('‚úì Successfully processed', filename);
                  
                } catch (error) {
                  console.error('‚úó Error processing', filename, ':', error.message);
                  process.exit(1);
                }
              "
              
              # Verify the JSON is valid
              echo "Verifying JSON for $file:"
              node -e "
                try {
                  const data = JSON.parse(require('fs').readFileSync('/tmp/doc-processing/${SAFE_NAME}.meta', 'utf8'));
                  console.log('‚úì Valid JSON created for $file');
                  console.log('  - Filename:', data.filename);
                  console.log('  - Content length:', data.content.length);
                } catch (e) {
                  console.error('‚úó Invalid JSON for $file:', e.message);
                  process.exit(1);
                }
              "
            fi
          done

      - name: Setup Node.js
        if: steps.changed-files.outputs.files != ''
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Run Doc Style Checker
        if: steps.changed-files.outputs.files != ''
        run: |
          cat > check_docs.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const https = require('https');
          
          async function checkDocStyle(content, filename) {
            console.log(`üì§ Sending request for: ${filename}`);
            console.log(`üìù Content preview: ${content.substring(0, 100)}...`);
            console.log(`üìè Content length: ${content.length}`);
            
            const data = JSON.stringify({
              content: content,
              filename: filename
            });
            
            console.log(`üì¶ Request data size: ${data.length} bytes`);
            
            const options = {
              hostname: 'doc-style-checker.vercel.app',
              path: '/api/test-check',
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(data, 'utf8'),
                'User-Agent': 'GitHub-Actions-Doc-Checker/1.0'
              }
            };
            
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                let responseData = '';
                res.on('data', (chunk) => {
                  responseData += chunk;
                });
                res.on('end', () => {
                  try {
                    console.log(`üì® Response status: ${res.statusCode}`);
                    console.log(`üì® Response headers:`, JSON.stringify(res.headers));
                    console.log(`üì® Response body preview: ${responseData.substring(0, 500)}...`);
                    
                    if (res.statusCode !== 200) {
                      console.error(`‚ùå Non-200 status code: ${res.statusCode}`);
                      console.error(`‚ùå Full response: ${responseData}`);
                      throw new Error(`HTTP ${res.statusCode}: ${responseData}`);
                    }
                    const result = JSON.parse(responseData);
                    console.log(`‚úÖ Successfully parsed response for ${filename}`);
                    resolve(result);
                  } catch (e) {
                    console.error('‚ùå Response parsing error:', e.message);
                    console.error('‚ùå Raw response:', responseData);
                    reject(e);
                  }
                });
              });
              
              req.on('error', (e) => {
                console.error(`‚ùå Request error for ${filename}:`, e.message);
                reject(e);
              });
              
              req.setTimeout(45000, () => {
                console.error(`‚è∞ Request timeout for ${filename}`);
                req.destroy();
                reject(new Error('Request timeout after 45 seconds'));
              });
              
              console.log(`üöÄ Sending request to API...`);
              req.write(data);
              req.end();
            });
          }
          
          async function processAllFiles() {
            const processingDir = '/tmp/doc-processing';
            const results = {};
            
            if (!fs.existsSync(processingDir)) {
              console.log('No processing directory found');
              return results;
            }
            
            const metaFiles = fs.readdirSync(processingDir).filter(f => f.endsWith('.meta'));
            console.log(`Found ${metaFiles.length} file(s) to process`);
            
            for (const metaFile of metaFiles) {
              const metaPath = path.join(processingDir, metaFile);
              
              try {
                const metadata = JSON.parse(fs.readFileSync(metaPath, 'utf8'));
                console.log(`üîç Processing: ${metadata.filename}`);
                console.log(`üìÑ Content preview: "${metadata.content.substring(0, 150)}..."`);
                console.log(`üìè Content length: ${metadata.content.length} characters`);
                console.log(`üî§ Content type: ${typeof metadata.content}`);
                
                const result = await checkDocStyle(metadata.content, metadata.filename);
                results[metadata.filename] = result;
                
                const issueCount = result.issues ? result.issues.length : 0;
                console.log(`‚úÖ ${metadata.filename}: ${issueCount} issue(s) found`);
                
                await new Promise(resolve => setTimeout(resolve, 3000));
                
              } catch (error) {
                console.error(`‚ùå Error processing ${metaFile}:`, error.message);
                console.error(`‚ùå Error stack:`, error.stack);
                const filename = metaFile.replace('.meta', '');
                results[filename] = { error: error.message };
              }
            }
            
            return results;
          }
          
          processAllFiles()
            .then(results => {
              fs.writeFileSync('/tmp/style-check-results.json', JSON.stringify(results, null, 2));
              console.log('üìä Style check completed');
            })
            .catch(error => {
              console.error('‚ùå Style check failed:', error);
              process.exit(1);
            });
          EOF
          
          node check_docs.js

      - name: Post PR Comment
        if: steps.changed-files.outputs.files != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTION_TOKEN }}
          script: |
            const fs = require('fs');
            
            let results = {};
            try {
              const resultsData = fs.readFileSync('/tmp/style-check-results.json', 'utf8');
              results = JSON.parse(resultsData);
            } catch (error) {
              console.log('No results to process');
              return;
            }
            
            console.log(`Processing results for ${Object.keys(results).length} files`);
            
            let comment = '## üìù Doc Style Checker Results\n\n';
            let hasIssues = false;
            let totalIssues = 0;
            
            for (const [filename, result] of Object.entries(results)) {
              if (result.error) {
                comment += `### ‚ùå ${filename}\n**Error:** \`${result.error}\`\n\n`;
                continue;
              }
              
              if (!result.issues || result.issues.length === 0) {
                comment += `### ‚úÖ ${filename}\nNo style issues found!\n\n`;
                continue;
              }
              
              // Process the nested structure from your API
              let fileIssues = [];
              result.issues.forEach(categoryGroup => {
                if (categoryGroup.issues && Array.isArray(categoryGroup.issues)) {
                  categoryGroup.issues.forEach(issue => {
                    fileIssues.push({
                      category: categoryGroup.category,
                      ...issue
                    });
                  });
                }
              });
              
              if (fileIssues.length === 0) {
                comment += `### ‚úÖ ${filename}\nNo style issues found!\n\n`;
                continue;
              }
              
              hasIssues = true;
              totalIssues += fileIssues.length;
              comment += `### üìã ${filename}\n**${fileIssues.length} issue${fileIssues.length > 1 ? 's' : ''} found**\n\n`;
              
              // Group by category
              const byCategory = {};
              fileIssues.forEach(issue => {
                const cat = issue.category || 'General';
                if (!byCategory[cat]) byCategory[cat] = [];
                byCategory[cat].push(issue);
              });
              
              for (const [category, issues] of Object.entries(byCategory)) {
                comment += `#### ${category}\n\n`;
                
                issues.forEach((issue, i) => {
                  comment += `<details>\n<summary><strong>Issue ${i + 1}</strong></summary>\n\n`;
                  
                  if (issue.problem) {
                    comment += `**Problem:** ${issue.problem}\n\n`;
                  }
                  
                  if (issue.problematicText) {
                    comment += `**Text:**\n\`\`\`\n${issue.problematicText}\n\`\`\`\n\n`;
                  }
                  
                  if (issue.location) {
                    comment += `**Location:** ${issue.location}\n\n`;
                  }
                  
                  if (issue.suggestion) {
                    comment += `**Suggestion:** ${issue.suggestion}\n\n`;
                  }
                  
                  if (issue.guideline) {
                    comment += `**Guideline:** ${issue.guideline}\n\n`;
                  }
                  
                  comment += `</details>\n\n`;
                });
              }
            }
            
            if (hasIssues) {
              const summary = `üîç **Summary:** ${totalIssues} issue${totalIssues > 1 ? 's' : ''} found across ${Object.keys(results).length} file${Object.keys(results).length > 1 ? 's' : ''}\n\n`;
              comment = comment.replace('## üìù Doc Style Checker Results\n\n', `## üìù Doc Style Checker Results\n\n${summary}`);
            } else if (Object.keys(results).length > 0) {
              comment += 'üéâ **All documentation looks great!** No style issues found.\n\n';
            }
            
            comment += '---\n*Automated by [Doc Style Checker](https://doc-style-checker.vercel.app/) ‚Ä¢ Couchbase Documentation Style Guide*';
            
            try {
              const [owner, repo] = '${{ inputs.repository }}'.split('/');
              await github.rest.issues.createComment({
                issue_number: parseInt('${{ inputs.pull_request_number }}'),
                owner: owner,
                repo: repo,
                body: comment
              });
              console.log('‚úÖ Comment posted successfully');
            } catch (error) {
              console.error('‚ùå Failed to post comment:', error);
              throw error;
            }
